<X3D>
  <!-- This example giggles the view point up and down and side to side
  using C++ plugin setFrustum.cpp in this directory. -->
  <Engine>
    <RenderJob DEF='render'>
      <WindowGroup>
        <LocalWindow size='800 400' position='0 0' pipe=':0.0'>
          <Viewarea lowerLeft='0 0' upperRight='0.5 1'>
          </Viewarea>
          <Viewarea lowerLeft='0.5 0' upperRight='1 1'>
          </Viewarea>
        </LocalWindow>
        <LocalWindow size='300 300' position='500 500'>
          <Viewarea lowerLeft='0 0' upperRight='1 1'
            leftBuffer='TRUE' rightBuffer='FALSE'>
            <!-- surface points have to be counterclockwise
                   starting with the lower left corner.  Not
                   doing so will rotate your view which is okay
                   if that's what you want. -->
            <ProjectionViewModifier DEF='view0'
              surface='-0.5 -0.5 0, 0.5 -0.5 0, 0.5 0.5 0, -0.5 0.5 0'
              mono='TRUE'
              eyeSeparation='0'
              leftEye='TRUE'
              rightEye='FALSE'>
            </ProjectionViewModifier>
          </Viewarea>
        </LocalWindow>
      </WindowGroup>
    </RenderJob>
    
    <IOSensor DEF='setFrustum' type='setFrustum' isActive='TRUE'>
      <!-- We tried changing the frustum surface in C++ code too, but
           that function is not implemented in Instant Reality. -->
      <field accessType='outputOnly' name='viewPoint' type='SFMatrix4f'/>
    </IOSensor>

    <ROUTE fromNode='setFrustum' fromField='viewPoint'
      toNode='view0' toField='set_eyeTransform'/>
 
  </Engine>

  <Scene>
    <GradientBackground position='0 1' color='0 0.329 0.706 0 0.008 0.082'/>
    <transform translation="0 0 0">
      <shape>
        <appearance>
          <material diffuseColor='0.2 0.7 0.9'></material>
        </appearance>
        <box></box>
      </shape>
    </transform>
  </Scene>
</X3D>

